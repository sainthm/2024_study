# Docs

## 1장. 사용자 수에 따른 규모 확장성

### 단일 서버(1-tier)

- 비즈니스 로직, 데이터 저장 등을 처리하기 위해서 서버 구현용 언어(Java, Python 등) 사용
- 프레젠테이션용으로 클라이언트 구현용 언어(HTML, JS 등)
- HTTP 프토콜을 통해 반환될 응답 데이터의 포맷은 보통 JSON 사용

### 데이터베이스 고려(2-tier)

- 웹/모바일 트래픽 처리 서버(웹 계층) + 데이터베이스 서버(데이터 계층)
- 관계형 데이터베이스
    - 자료를 테이블과 열, 컬럼으로 표현
    - 전통의 강자 → 일반적인 데이터 저장 용도
- 비관계형 데이터베이스
    - 네 가지 부류로 나뉨
        - 키-값 저장소
        - 그래프 저장소
        - 컬럼 저장소
        - 문서 저장소
    - 사용이 바람직한 경우가 있음
        - 아주 낮은 레이턴시가 요구
        - 다루는 데이터가 비정형
        - 데이터(JSON, YAML, XML 등)를 직렬화(serilize), 역직렬화(deserialize) 할 수 있기만 한 경우
        - 아주 많은 양의 데이터를 저장할 필요가 있는 경우

### 수직적 규모 확장 vs 수평적 규모 확장

- Scale-up
    - 장점: 단순함
    - 단점:
        - 확장 한계
        - 장애에 대한 failover 방안
        - 다중화(redundancy) 방안
- Scale-out

### 로드밸런서

- 트래픽 부하 분산 역할
- 사용자는 로드밸런서 접근 → 웹서버가 직접 처리 X → 부하분산 + 서버 IP 노출 X → 보안 강화

### 데이터베이스 다중화

- 보통은 서버 사이에 master-slave 관계를 설정 → 원본은 주서버 + 사본은 부서버에 저장하는 방식
- 쓰기 연산은 주서버에서만 지원
- 부서버는 사본을 전달받음 → 읽기 연산 지원
- 대부분의 애플리케이션은 읽기 연산 비중이 쓰기 연산보다 훨씬 높음 → 부DB 수 > 주DB 수
- 데이터베이스 다중화 장점:
    - 더 나은 성능: 병렬로 처리될 수 있는 쿼리 수 증가
    - 안정성(Reliability)
    - 가용성(Availability)
- 멀티마스터, 원형 다중화(circular replication) 방식도 존재

### 캐시

- 자주 참조되는 데이터를 메모리 적재 → 뒤이은 요청을 보다 빨리 처리될 수 있도록 하는 저장소
- 애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우됨 → 캐시를 통해 완화 가능
- 장점:
    - 성능 개선
    - 데이터베이스 부하 감소
    - 캐시 규모에 대한 독립적 확장 가능
- 사용법: 캐시 서버들이 제공하는 API 사용(널리 사용되는 프로그래밍 언어로 작성, ex. memcached API)
- **캐시 계층**(Cache tier)
    - 데이터가 잠시 보관되는 곳 → 데이터베이스보다 훨씬 빠름
    - 읽기 주도형 캐시 전략(read-through caching strategy) 및 다양한 캐시 전략 존재
        - 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 전략 선택 필요
- 캐시 사용 시 고민/유의할 점
    - 캐시는 어떤 상황에 바람직한가? → 가끔씩 갱신, 자주 참조
    - 어떤 데이터를 캐시에 두어야하는가? → 영속성이 필요한지 고려
    - 캐시에 보관된 데이터는 어떻게 expire 되는가? → 만료 정책 필요
    - 일관성은 어떻게 유지되는가? → 데이터 저장소의 원본 vs 캐시 내 사본, 트랜잭션 및 확장에 대한 고려 필요
    - 장애는 어떻게 대처할 것인가? → 캐시 서버 한 두대만 있는 경우, SPOF 가 될 가능성 있음
    - 캐시 메모리는 얼마나 크게 잡을 것인가? → eviction, operprovision
    - 데이터 방출 정책은 무엇인가? → LRU(Least Recently Used)가 많이 쓰임, LFU(Least Frequently Used), FIFO 등 여러가지 방법이 있음

### CDN

- 정적 컨텐츠 전송에 사용되는 지리적으로 분산된 서버의 네트워크
- 이미지, 비디오, CSS, JS 파일 등을 캐싱 가능
- 동적 컨텐츠는 이 책의 범위를 넘음
    - 요약: 요청 경로, 질의 문자열, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML 페이지 캐싱
- CDN 사용 시 고려해야할 사항
    - 비용 → CDN으로 들어가고 나가는 데이터 전송양에 따라 요금 지불
    - 적절한 만료 시한 설정
    - CDN 장애에 대한 대처 방안
    - 컨텐츠 무효화 방법: 무효화 API, 오브젝트 버저닝

### Stateless 웹 계층

- 웹 계층의 수평적 확장 고려
    - 상태 정보(ex. 사용자 세션 데이터)를 웹 계층에서 제거해야함
    - 바람직한 방법은 상태 정보를 지속성 저장소에 보관 & 필요할 때 호출
- 상태 정보에 의존적인 아키텍처
    - 클라이언트 정보(상태)를 유지하여 요청들 사이에 공유
    - 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야함
    - 로드밸런서의 stick session 으로 구현 가능하나 로드밸런서에 부하를 줄 수 있음 + 뒷단에 서버 추가 및 제거도 까다로워짐
- 무상태 아키텍처
    - 웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져옴
    - 공유 저장소는 RDB, 캐시 시스템(ex. memcached, redis), NoSQL 일 수 있음

### 데이터 센터

- 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내 → 지리적 라우팅(geoDNS-routing, geo-routing)
- 다중 데이터 센터를 위한 기술적 요인
    - 트래픽 우회
    - 데이터 동기화(Synchronization): 보편적 전략 → 여러 데이터 센터에 걸쳐 다중화
    - 테스트, 배포: 자동화된 배포 도구 활용
- 시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트 분리 → 독립적 확장이 가능하게해야함
    - 이를 위해, 많은 분산 시스템에서 메시지 큐 활용

