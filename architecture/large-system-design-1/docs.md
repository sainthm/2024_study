# Docs

## 1장. 사용자 수에 따른 규모 확장성

### 단일 서버(1-tier)

- 비즈니스 로직, 데이터 저장 등을 처리하기 위해서 서버 구현용 언어(Java, Python 등) 사용
- 프레젠테이션용으로 클라이언트 구현용 언어(HTML, JS 등)
- HTTP 프토콜을 통해 반환될 응답 데이터의 포맷은 보통 JSON 사용

### 데이터베이스 고려(2-tier)

- 웹/모바일 트래픽 처리 서버(웹 계층) + 데이터베이스 서버(데이터 계층)
- 관계형 데이터베이스
    - 자료를 테이블과 열, 컬럼으로 표현
    - 전통의 강자 → 일반적인 데이터 저장 용도
- 비관계형 데이터베이스
    - 네 가지 부류로 나뉨
        - 키-값 저장소
        - 그래프 저장소
        - 컬럼 저장소
        - 문서 저장소
    - 사용이 바람직한 경우가 있음
        - 아주 낮은 레이턴시가 요구
        - 다루는 데이터가 비정형
        - 데이터(JSON, YAML, XML 등)를 직렬화(serilize), 역직렬화(deserialize) 할 수 있기만 한 경우
        - 아주 많은 양의 데이터를 저장할 필요가 있는 경우

### 수직적 규모 확장 vs 수평적 규모 확장

- Scale-up
    - 장점: 단순함
    - 단점:
        - 확장 한계
        - 장애에 대한 failover 방안
        - 다중화(redundancy) 방안
- Scale-out

### 로드밸런서

- 트래픽 부하 분산 역할
- 사용자는 로드밸런서 접근 → 웹서버가 직접 처리 X → 부하분산 + 서버 IP 노출 X → 보안 강화

### 데이터베이스 다중화

- 보통은 서버 사이에 master-slave 관계를 설정 → 원본은 주서버 + 사본은 부서버에 저장하는 방식
- 쓰기 연산은 주서버에서만 지원
- 부서버는 사본을 전달받음 → 읽기 연산 지원
- 대부분의 애플리케이션은 읽기 연산 비중이 쓰기 연산보다 훨씬 높음 → 부DB 수 > 주DB 수
- 데이터베이스 다중화 장점:
    - 더 나은 성능: 병렬로 처리될 수 있는 쿼리 수 증가
    - 안정성(Reliability)
    - 가용성(Availability)
- 멀티마스터, 원형 다중화(circular replication) 방식도 존재

### 캐시

- 자주 참조되는 데이터를 메모리 적재 → 뒤이은 요청을 보다 빨리 처리될 수 있도록 하는 저장소
- 애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우됨 → 캐시를 통해 완화 가능
- 장점:
    - 성능 개선
    - 데이터베이스 부하 감소
    - 캐시 규모에 대한 독립적 확장 가능
- 사용법: 캐시 서버들이 제공하는 API 사용(널리 사용되는 프로그래밍 언어로 작성, ex. memcached API)
- **캐시 계층**(Cache tier)
    - 데이터가 잠시 보관되는 곳 → 데이터베이스보다 훨씬 빠름
    - 읽기 주도형 캐시 전략(read-through caching strategy) 및 다양한 캐시 전략 존재
        - 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 전략 선택 필요
- 캐시 사용 시 고민/유의할 점
    - 캐시는 어떤 상황에 바람직한가? → 가끔씩 갱신, 자주 참조
    - 어떤 데이터를 캐시에 두어야하는가? → 영속성이 필요한지 고려
    - 캐시에 보관된 데이터는 어떻게 expire 되는가? → 만료 정책 필요
    - 일관성은 어떻게 유지되는가? → 데이터 저장소의 원본 vs 캐시 내 사본, 트랜잭션 및 확장에 대한 고려 필요
    - 장애는 어떻게 대처할 것인가? → 캐시 서버 한 두대만 있는 경우, SPOF 가 될 가능성 있음
    - 캐시 메모리는 얼마나 크게 잡을 것인가? → eviction, operprovision
    - 데이터 방출 정책은 무엇인가? → LRU(Least Recently Used)가 많이 쓰임, LFU(Least Frequently Used), FIFO 등 여러가지 방법이 있음

### CDN

- 정적 컨텐츠 전송에 사용되는 지리적으로 분산된 서버의 네트워크
- 이미지, 비디오, CSS, JS 파일 등을 캐싱 가능
- 동적 컨텐츠는 이 책의 범위를 넘음
    - 요약: 요청 경로, 질의 문자열, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML 페이지 캐싱
- CDN 사용 시 고려해야할 사항
    - 비용 → CDN으로 들어가고 나가는 데이터 전송양에 따라 요금 지불
    - 적절한 만료 시한 설정
    - CDN 장애에 대한 대처 방안
    - 컨텐츠 무효화 방법: 무효화 API, 오브젝트 버저닝

### Stateless 웹 계층

- 웹 계층의 수평적 확장 고려
    - 상태 정보(ex. 사용자 세션 데이터)를 웹 계층에서 제거해야함
    - 바람직한 방법은 상태 정보를 지속성 저장소에 보관 & 필요할 때 호출
- 상태 정보에 의존적인 아키텍처
    - 클라이언트 정보(상태)를 유지하여 요청들 사이에 공유
    - 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야함
    - 로드밸런서의 stick session 으로 구현 가능하나 로드밸런서에 부하를 줄 수 있음 + 뒷단에 서버 추가 및 제거도 까다로워짐
- 무상태 아키텍처
    - 웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져옴
    - 공유 저장소는 RDB, 캐시 시스템(ex. memcached, redis), NoSQL 일 수 있음

### 데이터 센터

- 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내 → 지리적 라우팅(geoDNS-routing, geo-routing)
- 다중 데이터 센터를 위한 기술적 요인
    - 트래픽 우회
    - 데이터 동기화(Synchronization): 보편적 전략 → 여러 데이터 센터에 걸쳐 다중화
    - 테스트, 배포: 자동화된 배포 도구 활용
- 시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트 분리 → 독립적 확장이 가능하게해야함
    - 이를 위해, 많은 분산 시스템에서 메시지 큐 활용


### 메세지 큐

- 메세지의 무손실을 보장하는 비동기 통신 지원 컴포넌트
  - 무손실(durability): 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관되는 성질
- 메시지의 버퍼 역할
- 비동기적으로 전송
- 아키텍처:
  - 생산자/발행자(producer/publisher): 입력 서비스 → 메시지를 만들어서 메시지 큐에 발행(publish)
- 소비자/구독자(consumer/subscriber): 메시지를 받아 그에 맞는 동작 수행
- 메세지 큐 장점:
    - 서비스, 서버 간 느슨한 결합(loosely coupled) → 규모 확장성 보장
    - 비동기 통신/처리


### 로그, 메트릭 그리고 자동화

- 웹 사이트와 함께 사업 규모가 커지고 나면 이러한 도구에 필수적으로 투자해야함
- 로그:
    - 에러 로그 모니터링 중요 → 시스템의 오류와 문제들을 보다 쉽게 찾아낼 수 있음
        - 서버 단위로 모니터링 가능
        - 로그를 단일 서비스로 모아주는 도구를 활용하면 더욱 편리하게 검색, 조회 가능
- 메트릭:
    - 사업 현황에 관한 유용한 정보를 얻을 수 있음
    - 시스템의 현재 상태를 손쉽게 파악 가능
        - 호스트 단위 메트릭:
            - CPU
            - Mem
            - Disk I/O
            - 등등
        - 종합(aggregated) 메트릭:
            - 데이터베이스 계층 성능
            - 캐시 계층 성능
            - 등등
        - 핵심 비즈니스 메트릭:
            - 일별 능동 사용자(daily active user)
            - 수익
            - 재방문(retention)
            - 등등
- 자동화:
    - 시스템이 크고 복잡해지면 생산성을 높이기 위해, 자동화 도구를 활용해야함
    - 지속적 통합(CI), 빌드, 테스트, 배포 등의 절차를 자동화하면 개발 생산성을 크게 향상 시킬 수 있음


### 데이터베이스의 규모 확장

- 저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가 → 데이터베이스 증설 방법 필요
- 두 가지 접근법:
    - 수직적 규모 확장법
    - 수평적 규모 확장법
- 수직적 확장
    - 스케일 업
    - 약점:
        - 서버 하드웨어 한계 → 무한 증설 불가능
        - SPOF
        - 비용
- 수평적 확장
    - 데이터베이스의 수평적 확장 → 샤딩(Sharding)
        - 샤딩: 대규모 데이터베이스를 샤드(shard)로 분할하는 기술
            - 모든 샤드는 같은 스키마를 사용
            - 샤드에 보관되는 데이터 사이에 중복 X
            - 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 정함
            - 훌륭한 기술이지만 완벽하지는 않음 → 도입 시, 시스템이 복잡해지고 새로운 문제도 발생할 수 있음
                - 데이터의 재 샤딩(resharding):
                    - 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 경우 사용
                    - 샤드 간 데이터 분포가 균등하지 못하여, 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빠르게 진행(샤드 소진(shard exaustion))될 때 사용 → 샤드 키를 계산하는 함수 변경 + 데이터 재배치 필요 → 안정 해시(consistent hashing) 기법 활용
                - 유명인사(celebrity) 문제:
                    - 핫스팟 키 문제 라고도 부름
                    - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
                - 조인과 비정규화:
                    - 여러 샤드에 걸친 데이터를 조인하기 힘들어짐 → 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 함
        - 샤딩 키(sharding key) → 샤딩 전략을 구현할 때 고려해야할 가장 중요한 요소
            - 파티션 키라고도 부름
            - 데이터가 어떻게 분산될지 정하는 하나 이상의 컬럼으로 구성(ex. user_id)
            - 샤딩 키를 통해, 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경 처리 → 효율 증가
            - 샤딩 키를 정할 때, 데이터를 고르게 분할 할 수 있도록 하는게 가장 중요함


### 백만 사용자, 그리고 그 이상

- 시스템 규모를 확장하는 것은 지속적이고 반복적(iterative)인 과정
- 수백만 사용자 이상을 지원하려면 새로운 전략 도입 필요 + 지속적으로 시스템을 가다듬어야함
- 시스템 규모 확장을 위해 살펴본 기법 정리:
    - 웹 계층 → stateless 계층
    - 모든 계층에 다중화 도입
    - 가능한 한 많은 데이터 캐싱
    - 여러 데이터 센터 지원
    - 정적 콘텐츠 → CDN 활용
    - 데이터 계층 → 샤딩을 통한 확장
    - 각 계층은 독립적 서비스로 분할
    - 지속적으로 모니터링, 자동화 도구 활용



<br>

## 2장. 개략적인 규모 추정

- 시스템 설계 면접: 시스템 용량, 성능 요구사항을 개략적으로 추정해 보라는 요구를 받게 될 수도 있음
- 개략적인 규모 추정(back-of-the-envelope extimation): 사고 실험 → 추정치 계산
- 기본기에 능숙해야함
    - 2의 제곱수
    - 응답지연 값
    - 고가용성에 관계된 수치
    - 등등

### 2의 제곱수

- 분산 시스템에서 다루는 데이터 양은 엄청나게 커질 수 있으나 그 계산법은 기본을 크게 벗어나지 않음!
- 데이터 볼륨 단위에 대한 이해 필요

| 2의 x 제곱 | 근사치 | 이름 | 축약형 |
| --- | --- | --- | --- |
| 10 | 1천(thousand) | 1킬로바이트 | 1KB |
| 20 | 1백만(million) | 1메가바이트 | 1MB |
| 30 | 10억(billion) | 1기가바이트 | 1GB |
| 40 | 1조(trillion) | 1테라바이트 | 1TB |
| 50 | 1000조(quadrillion) | 1페타바이트 | 1PB |

### 모든 프로그래머가 알아야 하는 응답지연 값

- 메모리는 빠르지만 디스크는 아직도 느림
- 디스크 탐색(seek)은 가능한 피하자
- 단순한 압축 알고리즘은 빠름
- 데이터를 인터넷을 전송하지 전에 가능하면 압축
- 데이터 센터는 보통 여러 리전에 분산되어 있고, 센터들 간에 데이터를 주고받는 데는 시간이 걸림

### 가용성에 관계된 수치들

- 고가용성(high availability): 시스템이 오랜 시간 동안 지속적으로 중단 없이 운영될 수 있는 능력
- 퍼센트로 표현
- SLA(Service Level Agreement): 서비스 사업자와 고객 사이에 맺어진 합의 → 가용시간(uptime)이 공식적으로 기술
    - 관습적으로 숫자 9를 활용하여 표현

### 예제: 트위터 QPS와 저장소 요구량 추정

- QPS(Query Per Second) 계산 예시
- 문제를 풀어나가는 절차가 중요 → 문제해결 능력
- 근사치 활용 계산(rounding and approximation)
- 가정(assumption)
- 단위 중요!
- 개략적 규모 추정 관련 빈출 문제:
    - QPS
    - 최대 QPS
    - 저장소 요구량
    - 캐시 요구량
    - 서버 수 추정
    - 등등


<br>


## 3장. 시스템 설계 면접 공략법

- 시스템 설계 면접 → 동료들이 모호한 문제를 풀기 위해 협력하여 그 해결책을 찾아내는 과정에 대한 시뮬레이션
- 면접관의 일차적 목표: 면접자의 능력을 평가하는 것
- 면접관이 시스템 설계 면접에서 찾고자하는 것은 무엇일까?

### 효과적 면접을 위한 4단계 접근법

- 1단계: 문제 이해 및 설계 범위 확정
    - 요구사항을 완전히 이해하지 않고 답을 내놓는 행위는 아주 엄청난 부정적 신호(red flag)
    - 깊이 생각하고 질문하여 요구사항과 가정들을 분명히 하라!
    - 엔지니어가 가져야 할 가장 중요한 기술 중 하나는 **`올바른 질문을 하는 것`**, `**적절한 가정을 하는 것**`, **`시스템 구축에 필요한 정보를 모으는 것`**
        - 구체적으로 어떤 기능들을 만들어야 하나?
        - 제품 사용자 수는 얼마나 되나?
        - 회사의 규모는 얼마나 빨리 커지리라 예상하나?
        - 회사가 주로 사용하는 기술 스택은 무엇인가?
        - 등등
- 2단계: 개략적인 설계안 제시 및 동의 구하기