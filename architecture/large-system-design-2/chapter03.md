
# 3장. 구글 맵

> 실제 우리가 사용하는 제품보다는 단순한 형태의 구글 맵 설계

### 구글 맵

- 2005년 프로젝트 구글 맵 발족 → 웹 기반 지도 서비스 개발
- 위성 이미지, 거리 뷰, 실시간 교통 상황, 경로 계획 등 다양한 서비스 제공
- 사용자가 목적지와 경로를 찾을 수 있도록 도움
- 2021년 3월 기준 DAU 10억명
- 전 세계 99% 지역의 지도 제공
- 정확한 실시간 위치 정보를 제공하기 위해 매일 2500만 건의 업데이트 반영
- 엄청나게 복잡한 제품


## 1단계: 문제 이해 및 설계 범위 확정

- DAU: 10억명
- 개발 포인트: 위치 갱신, 경로 안내, ETA(Estimated Time of Arrival), 지도 표시
- 도로 데이터: 다양한 경로를 확보했다고 가정하며, 수 TB 수준의 가공되지 않은 데이터
- 실시간 교통상황 고려
- 다양한 이동방법 고려(운전, 대중교통, 도보 등)
- 경유지 고려 X
- 사업장 위치 및 사진 출력 고려 X


### 기능 요구사항

> 지원할 주 단말은 스마트폰으로 가정
> 
- 사용자 위치 갱신
- 경로 안내 서비스 (ETA 포함)
- 지도 표시

### 비기능 요구사항 및 제약사항

- 정확도
- 부드러운 경로 표시
- 데이터 및 배터리 사용량
- 가용성 및 규모 확장성 고려

## 지도 101

### 측위 시스템

> 측위 시스템(positioning system): 구 표면 상의 위치를 표현하는 체계

- 위경도 기반 측위 시스템의 경우, 최상단에는 북극이 있고 최하단에는 남극이 위치
- 측위 시스템 내 표현:
    - 위도: 주어진 위치가 얼마나 북쪽/남쪽인지 표현
    - 경도: 얼마나 동쪽/서쪽인지 표현

### 3차원 위치의 2차원 변환

> 지도 투영법(map projection): 3차원 구 위의 위치를 2차원 평면에 대응시키는 절차 (a.k.a 도법)

- 도법은 다양하며, 각각은 다른 도법과 차별되는 장단점이 있음
- 거의 모든 투영법은 실제 지형의 기하학적 특성을 왜곡한다는 공통점이 있음
- 도법 예시:
    - 메르카토르 도법
    - 퍼스 퀸쿤셜 도법
    - 칼-페터스 도법
    - 윈켈 트리펠 도법
- 구글 맵은 메르카토르 도법을 조금 변형한 `웹 메르카토르` 도법 채택

### 지오코딩

> 지오코딩(Geocoding): 주소를 지리적 측위 시스템의 좌표로 변환하는 프로세스
> 
- 지오코딩 결과를 반대로 주소로 변환하는 프로세스는 역 지오코딩
- 지오코딩 수행 방법:
    - 인터폴레이션(Interpolation, 써넣음, 보간법):
        - GIS(Geographic Information System)와 같은 다양한 시스템이 제공하는 데이터 결합
        - 도로망을 지리적 좌표 공간에 대응시키는 방법을 제공하는 여러 시스템 가운데 하나

### 지오해싱

> 지오해싱(Geohashing): 지도 위 특정 영역을 영문자와 숫자로 구성된 짧은 문자열에 대응시키는 인코딩 체계
> 
- 2차원의 평면 공간으로 표현된 지리적 영역 위의 격자를 더 작은 격자로 재귀적으로 분할
- 각 격자는 정사각형일 수도 있고 사각형일 수도 있음
- 어떤 격자를 재귀적으로 분할한 결과로 생성된 더 작은 격자에는 0부터 3까지의 번호를 부여
- 원하는 크기의 격자가 만들어질 때까지 반복하여 분할
- 다양한 용도가 있음


### 지도표시

> 지도를 화면에 렌더링
> 
- 타일: 지도를 화면에 표시하는 가장 기본적인 개념
    - 지도를 하나의 이미지로 표시하는 대신 작은 타일로 쪼개어 표시
    - 클라이언트는 사용자가 보려는 영역에 관계된 타일만 다운받아 모자이크처럼 이어 붙인 다음 화면에 뿌림
    - 지도의 확대/축소를 지원하려면 확대 수준에 따라 다른 종류의 타일 준비 필요
    - 현재 클라이언트가 보려는 지도 확대 수준(zoom level)에 근거하여 어떤 크기의 타일을 가져올지 고름


### 경로 안내 알고리즘을 위한 도로 데이터 처리

- 대부분의 경로 탐색 알고리즘은 `데이크스트라(Djikstra) 알고리즘`이나 `A* 경로 탐색 알고리즘`의 변종
- 모든 경로 탐색 알고리즘은 교차로를 노드, 도로는 노드를 잇는 엣지로 표현하는 `그래프 자료 구조` 가정
- 대부분의 경로 탐색 알고리즘의 성능은 주어진 그래프 크기에 민감 → 관리 기능 단위로 분할할 필요가 있음
- 전 세계 도로망을 더 작은 단위로 분할하는 방법 가운데 하나는 지도 표시에 사용하는 타일 기반 분할법과 유사함
    - 지오해싱과 비슷한 분할 기술을 적용하여 세계를 작은 격자로 나눔
    - 각 격자 안의 도로망을 노드와 엣지로 구성된 그래프 자료 구조로 변환
    - 각 격자는 경로 안내 타일(routing tile)이라고 부름
    - 각 타일은 도로로 연결된 다른 타일에 대한 레퍼런스를 유지
- 지도 타일 → PNG (이미지 파일)
- 경로 안내 타일 → Binary file (도로 데이터로 구성)

### 계층적 경로 안내 타일

> 경로 안내가 효과적으로 동작하려면 필요한 수준의 구체성을 갖춘 도로 데이터 필요
> 
- 보통 구체성 정도를 상, 중, 하로 구분하여 세 가지 종류의 경로 안내 타일 준비
    
    
    | 구분 | 구체성 | 크기 | 데이터 |
    | --- | --- | --- | --- |
    | 상 | 높음 | 작음 | 지방도로 수준(local roads) |
    | 중 | 중간 | 중간 | 간선도로 수준(arterial roads) |
    | 하 | 낮음 | 큼 | 고속도로 수준(expressway) |
- 각 타일에는 다른 정밀도 타일로 연결되는 엣지가 있을 수 있음


## 개략적 규모 추정

- 거리 참고사항:
    - 1피트 = 0.3408 미터
    - 1킬로미터 = 0.6214 마일
    - 1킬로미터 = 1000미터

### 저장소 사용량

- 세계 지도
- 메타데이터
- 도로 정보 → 외부에서 받은 수 TB 용량의 도로 데이터 보유

### 세계 지도

- 지도를 확대(zoom in)할 때마다 하나의 타일을 네 장의 타일로 펼친다고 가정
- 세계 지도를 21번 확대하여 볼 수 있으려면 4.4조개의 타일 필요
- 한 장의 타일이 256 x 256 픽셀 압축 PNG 파일 → 100KB의 저장공간 필요
- 최대 확대시 필요 타일을 전부 저장하려면

$4.4 조 * 100 KB = 440 PB$

- 지구 표면 가운데 90%는 인간이 살지 않는 자연 그대로의 바다, 사막, 호수, 산간 지역 → 높은 비율로 압축 가능 → 80~90% 가량의 저장 용량 절감 가능

$440 PB * 0.2 = 88PB$

- 설계안에서는 50PB로 가정
- 각 수준별로 얼마나 많은 저장공간이 필요할까?


$50 + 50/4 + 50/16  + 50/64 + ... =~ 67PB$

- 대략적으로 `100PB` 정도 소요


### 서버 대역폭

- 어떤 유형의 요청을 처리해야할까?
- 크게 두 가지 요청
    - 경로 안내 요청
    - 위치 갱신 요청
- DAU → 10억
- 각 사용자는 경로 안내 기능을 평균적으로 주당 35분 사용한다고 가정 → 주당 350 억 분 → 하루에 50 억 분
- 15초마다 한 번씩 서버로 보낸다고 가정

$QPS = 50억 * 60 / 10^5 * 15 = 200,000(query/sec)$

- 최대 QPS는 평균치의 다섯 배로 가정

$최대 QPS = 200,000 * 5 = 1,000,000$



### 위치 서비스

> 사용자의 위치를 기록하는 역할 담당
> 
- 클라이언트가 t 초 마다 자신의 위치를 전송한다고 가정
    - t 는 설정 가능한 값
- 주기적으로 위치 정보를 전송하여 얻는 장점
    - 해당 데이터 스트림을 활용하여 시스템을 점진적으로 개선 가능
        - 실시간 교통 상황 모니터링 용도로 활용 가능
        - 새로 만들어진 도로나 폐쇄된 도로 탐지 가능
        - 사용자 행동 양태를 분석하여 개인화된 경험 제공 가능
    - 클라이언트가 보내는 위치 정보가 거의 실시간에 가까우므로 ETA를 좀 더 정확하게 산출할 수 있음
    - 교통 상황에 따라 다른 경로로 안내할 수 있음
- 위치 이력을 클라이언트에 버퍼링 해두었다가 일괄 요청하면 전송 빈도를 줄일 수 있음
- 구글 맵과 같은 시스템은 이렇게 위치 갱신 요청 빈도를 줄여도 여전히 많은 쓰기 요청을 처리해야함
    - 카산드라 활용
        - 아주 높은 쓰기 요청 빈도에 최적화
        - 규모 확장 용이
    - 카프카 활용
        - 스트림 처리 엔진을 활용하여 위치 데이터 로깅
- 통신 프로토콜
    - HTTP를 keep-alive 옵션과 함께 사용

```bash
# HTTP 요청 예시
POST /v1/locations
인자:
locs: JSON으로 인코딩한 (위도, 경도, 시각) 순서쌍 배열
```


### 경로 안내 서비스

> A 에서 B 지점으로 가는 합리적으로 빠른 경로를 찾아주는 역할 담당
> 
- 결과를 얻는 데 드는 시간 지연은 어느 정도 감내
- 계산된 경로는 최단 시간 경로일 필요는 없으나 정확도는 보장되어야함
- 경로 재탐색, 교통 상황 변화는 고려 X
    - 상세설계의 적응형 ETA(adaptive ETA)를 통해 해결 가능

```bash
# API 요청 예시
GET /v1/nav?origin=1355+market+street,SF&destination=Disneyland

# 경로 안내 결과값 예시
{
  'distance'
  'duration'
  'end_location'
  'html_instructions'
  'policyline'
  'start_location'
  'geocoded_waypoints': [
  {
    "geocoder_status"
    "partial_match"
    "place_id"
    "types"
  },
  {
    "geocoder_status"
    "partial_match"
    "place_id"
    "types"
  }
  ],
  'travel_mode': 'DRIVING'
}
```

### 지도 표시

> 클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타일을 서버에서 가져오는 접근법이 바람직함
> 
- 클라이언트는 언제 지도타일을 서버에서 가져올까?
    - 사용자가 지도를 확대 또는 이동시키며 주변을 탐색할 때
    - 경로 안내가 진행되는 동안 사용자의 위치가 현재 지도 타일을 벗어나 인접한 타일로 이동할 때
- 선택지 1:
    - 클라이언트의 위치, 현재 클라이언트가 보는 지도의 확대 수준에 근거하여 필요한 지도 타일을 즉석에서 만드는 방안
    - 사용자 위치 및 확대 수준의 조합이 무한대에 가까움 → 심각한 문제가 발생할 수 있음
        - 모든 지도 타일을 동적으로 만들어야 하는 서버 클러스터에 심각한 부하 발생
        - 캐시 활용의 어려움
- 선택지 2:
    - 확대 수준별로 미리 만들어 둔 지도 타일을 클라이언트에 전달하기만 하는 방법
        - 각 지도 타일은 고정된 사각형 격자로 표현되는 정적 데이터
    - 클라이언트는 지도 타일이 필요할 경우 현재 확대 수준에 근거하여 필요한 지도 타일 집합 결정
    - 각 위치를 지오해시 URL로 변환
    - 정적 이미지는 CDN을 통해 서비스
    - 장점:
        - 규모 확장성 용이함
        - 성능 측면에서도 유리함
        - 사용자에게 가까운 POP(Point of Presence) 서버에서 파일을 서비스


### 데이터 사용량

- 클라이언트 측 캐시 고려하지 않은 계산법
- 사용자는 30km/h 속도로 이동중
- 한 이미지가 200m x 200m 영역을 표현하도록 확대한 상태
- 이미지 하나는 256 x 256 픽셀 → 평균 이미지 크기 100KB
- 1km x 1km 영역 표현에 25 장의 이미지 필요

$시간당 데이터 소비량 = 25 * 100KB * 30 = 75MB/hour  >> (1.25MB/min)$



### CDN을 통해 서비스되는 트래픽 규모

- 매일 50억 분 가량의 경로 안내 처리

$50억 * 1.25MB = 6.25PB/day$

$지도데이터 전송량 = 6.25PB / 10^5 sec/day = 62,500MB/sec$

- 전세계에 200개의 POP 존재 가정

$CDN >> 62,500 / 200 = 312.5MB/sec$

- 지오해시를 통해 격자를 나누므로 모든 격자는 고유한 지오해시 값을 갖음
- 위도/경도로 표현된 클라이언트의 위치 및 ㅎ현재 재도 확대 수준을 입력으로 화면에 표시할 지도 타일에 대응되는 지오해시는 아주 쉽게 계산 가능
- `해당 계산은 지도를 화면에 표시할 클라이언트가 수행` → 해당 지오해시 및 URL로 CDN에서 지도 타일을 가져오면 됨

```bash
# URL 예시
https://cdn.map-provieder.com/tiles/9q9hvu.png
```

- 앞의 내용처럼 지오해시 계산은 클라이언트가 수행해도 괜찮음
    - 하지만 해당 알고리즘을 클라이언트에 구현해 놓으면 지원해야할 플랫폼이 많을 때 문제가 될 수도 있음을 유의
    - 모바일 앱 업데이트 배포는 시간도 많이 걸리고 때로는 위험한 프로세스
    - 맵 타일 인코딩에는 지오해싱을 사용하리라는 보장이 있어야함
    - 다른 인코딩 방안으로 교체해야 한다면 많은 노력이 필요하며 위험성도 만만치 않음
- 주어진 위도/경도 및 확대 수준을 타일 URL로 변환하는 알고리즘 구현을 별도 서비스에 두는 방식
    - 해당 서비스는 위도, 경도, 현재 확대 수준을 입력으로하여 타일 URL을 계산하는 역할만 담당
    - 운영 유연성이 높아지므로 고려해볼 가치가 있음
    - 로직:
        - 사용자가 새로운 위치로 이동하거나 확대 수준을 변경하면 지도 타일 서비스는 어떤 타일이 필요한지 결정하여 해당 타일들을 가져오는 데 필요한 URL 집합을 계산
        1. 모바일 사용자가 타일 URL 들을 가져오기 위해 지도 타일 서비스를 호출
        2. 요청은 로드밸런서로 전달
        3. 지도 타일 서비스는 클라이언트의 위치와 확대 수준을 입력으로 삼아 9개의 타일 URL을 계산한 다음 클라이언트에 반환
        4. 표시한 타일 하나와 8개의 주변 타일이 응답에 포함
        5. 모바일 클라이언트는 해당 타일을 CDN을 통해 다운로드


# 3단계: 상세 설계

## 데이터 모델

- 네 가지 데이터를 취급
    - 경로 안내 타일
    - 사용자 위치
    - 지오코딩 데이터
    - 미리 계산해 둔 지도 타일 데이터

### 경로 안내 타일

- 방대한 양의 도로 및 메타데이터(이름, 관할구, 위도, 경도 등의 도로 부속 정보)로 구성
- 그래프 자료 구조 형태로 가공되지 않은 데이터
- 주어진 상태 그대로는 경로 안내 알고리즘의 입력으로 활용할 수 없음
- `경로 안내 타일 처리 서비스` 로 명칭한 오프라인 데이터 가공 파이프라인을 주기적으로 실행하여 경로 안내 타일로 변환 → 도로 데이터에 발생한 새로운 변경사항을 반영
- 가공 결과로 만든 타일을 어디에 저장해야할까?
    - 일반적으로 그래프 데이터는 메모리에 인접 리스트(adjacency list) 형태로 보관
    - 본 설계안이 다루는 타일 데이터는 메모리에 두기에는 양이 너무 많음
    - 그래프의 노드와 선을 데이터베이스 레코드로 저장하는 것도 방법이겠지만 비용이 많이 발생
    - 경로 안내 타일의 경우 데이터베이스가 제공하는 기능이 필요 없음
- 경로 안내 타일을 저장하는 효율적 방법은 S3 같은 `오브젝트 스토리지`에 파일을 보관하고 그 파일을 이용할 경로 안내 서비스에서 `적극적으로 캐싱`
- 인접 리스트를 이진 파일 형태로 직렬화 해주는 고성능 소프트웨어 패키지는 많음
    - 타일을 객체 저장소에 보관할 때는 지오해시 기준으로 분류
    - 위도와 경도가 주어졌을 때 타일을 신속하게 찾을 수 있음


### 사용자 위치 데이터

- 사용자의 위치 정보는 아주 값진 데이터!
    - 도로 데이터 및 경로 안내 타일을 갱신하는데 이용
    - 실시간 교통 상황 데이터
    - 교통 상황 이력 데이터베이스를 구축하는 데도 활용 가능
    - 데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리하여 지도 데이터 갱싱
- 사용자 위치 데이터를 저장하려면 엄청난 양의 쓰기 연산을 잘 처리하며 수평적 규모 확장이 가능한 데이터베이스 필요 → 카산드라
    - 해당 데이터베이스의 레코드 예시 (사용자 위치 테이블)
        
        
        | user_id | timestamp | user_mode | driving_mode | location |
        | --- | --- | --- | --- | --- |
        | 101 | 1635740977 | active | driving | (20.0, 30.5) |

### 지오코딩 데이터베이스

- 주소를 위도/경도 쌍으로 변환하는 정보 보관
- 읽기 연산은 빈번하지만 쓰기 연산은 드물게 발생 → `레디스`처럼 빠른 읽기 연산을 제공하는 키-밸류 저장소가 적당함
- 출발지와 목적지 주소는 경로 계획 서비스에 전달하기 전에 해당 데이터베이스를 통해 위도/경도 쌍으로 변환되어아햠

### 미리 만들어 둔 지도 이미지

- 단말이 특정 영역의 지도를 요청하면 인근 도로 정보를 취합하여 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어내야함
- 계산 자원을 많이 사용 + 같은 이미지를 중복 요청하는 경우가 많음 → 이미지는 한 번만 계산하고 그 결과는 캐시해 두는 전략을 사용하는 것이 좋음
- 이미지는 지도 표시에 사용하는 확대 수준별로 미리 생성 → CDN을 통해 전송


### 위치 서비스

> 데이터베이스 설계 및 사용자 위치 정보가 이용되는 방식에 초점
> 
- 사용자 위치 데이터 저장에는 키-밸류 저장소 활용
- 초당 백만 건의 위치 정보 업데이트가 발생한다는 점을 감안하면 쓰기 연산 지원에 탁월한 데이터베이스 필요
    - NoSQL 키-밸류 데이터베이스
    - Column-oriented 데이터베이스
- 사용자 위치는 계속 변경 → 데이터 일관성보다 `가용성`이 더 중요
    - CAP 정리: 일관성, 가용성, 분할 내성 모두를 만족시킬 방법은 없음
- 본 설계안에서는 `가용성`과 `분할 내성`에 집중
- 해당 요구사항에 가장 적합한 데이터베이스는 카산드라
    - 높은 가용성 보장
    - 막대한 규모의 연산 감당
- 데이터베이스 키로 (user_id, timestamp) 조합 사용
- 해당 키에 매달리는 값으로는 위도/경도 쌍을 저장
    - user_id → 파티션 키 → 같은 파티션 키를 갖는 데이터는 함께 저장
    - timestamp → 클러스터링 키 → 정렬
    
    | key(user_id) | timestamp | lat | long | user_mode | navigation_mode |
    | --- | --- | --- | --- | --- | --- |
    | 51 | 132053000 | 21.9 | 89.8 | active | driving |

### 사용자 위치 데이터는 어떻게 이용되는가

- 사용자 위치는 쓰임새가 다양한 중요 데이터
    - 새로 개설되었거나 폐쇄된 도로 감지
    - 지도 데이터의 정확성을 점차로 개선하는 입력으로 활용
    - 실시간 교통 현황 파악하는 입력으로 활용
- 사용자 위치를 데이터베이스에 기록하는 것과 별도로 카프카와 같은 메시지 큐에 로깅
    - 카프카:
        - 응답 지연이 낮고 많은 데이터를 동시에 처리할 수 있는 데이터 스트리밍 플랫폼
        - 실시간 데이터 피드를 지원하기 위해 고안
- 개별 서비스는 카프카를 통해 전달되는 사용자 위치 데이터 스트림을 각자 용도에 맞게 활용
    - 교통량 데이터베이스 갱신
    - 경로 안내 타일
    - 분석 데이터베이스
    - 개인화 데이터베이스
    - 등등

## 지도 표시

- 지도 타일을 미리 만들어 놓는 방법
- 지도 표시 최적화 기법

### 지도 타일 사전 계산

- 확대 수준을 한 단계 올릴 때마다 해당 수준을 위한 전체 타일 수는 동서 방향아로 두 배, 남북 방향으로 두 배늘어남 → 각 타일의 크기는 여전히 동일
- 클라이언트는 해당 정보를 제공하기 위한 타일을 다운 받는 데 많은 네트워크 대역폭을 소진하지 않고도 클라이언트에 설정된 확대 수준에 최적인 크기의 지도를 표시 가능
- 화면에 한 번에 표시 가능한 지도 타일 개수는 달라지지 않기 때문!

### 최적화: 벡터 사용













