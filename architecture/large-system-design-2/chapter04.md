### 4장 요약

# 4장. 분산 메시지 큐

> 시스템 설계 면접에 단골로 출제되는 문제인, 분산 메시지 큐 설계
> 
- 현대적 소프트웨어 아키텍처를 따르는 시스템은 잘 정의된 인터페이스를 경계로 나뉜 작고 독립적인 블록들로 구성
- 메시지 큐는 이 `블록 사이의 통신과 조율 담당`
- 유명 분산 메시지 큐:
    - 아파치 Kakka
    - 아파티 RocketMQ
    - 아파치 RabbitMQ
    - 아파치 Pulsar
    - 아파치 ActiveMQ
    - ZeroMQ

### 메시지 큐 장점:

- 결합도 완화(decoupling): 각각을 독립적으로 갱신 가능
- 규모 확장성 개선:
    - 아래의 컴포넌트를 시스템 규모에 대한 트래픽 부하에 맞게 독립적으로 늘릴 수 있음
        - 생산자(producer): 메시지 큐에 데이터 생산
        - 소비자(consumer): 큐에서 메시지를 소비
- 가용성 개선
- 성능 개선:
    - 비동기 통신이 쉽게 가능해짐
    - 서로를 기다릴 필요가 없어짐

### 메시지 큐 vs 이벤트 스트리밍 플랫폼

> 이번 장에서는 데이터 장기 보관, 메시지 반복 소비 등의 부가 기능을 갖춘 분산 메시지 큐 설계
> 
- 엄밀히 말하면 카프카와 펄사는 이벤트 스트리밍 플랫폼
- 지원하는 기능이 서로 수렴하며 구분이 희미해지고있음

## 1단계: 문제 이해 및 설계 범위 확정

> 프로듀서는 메시지를 큐에 보내고, 컨슈머는 큐에서 메시지를 꺼낸다.
> 
- 기본 기능 외에도 성능, 메시지 전달 방식, 데이터 보관 기관 등 고려할 사항 다양함
- 메시지의 형태와 평균 크기
- 텍스트 메시지 / 멀티미디어 지원
- 메시지의 반복적 소비 가능성
- 여러 컨슈머가 수신 가능해야 하는지
- 전달된 순서대로 소비되어야 하는지
- 데이터의 지속성 보장 여부
- 데이터의 보관 기간
- 프로듀서와 컨슈머의 수
- 메시지 전달 방식
    - 최대 한 번
    - 최소 한 번
    - 정확히 한 번
- 대역폭
- 엔드 투 엔드 지연시간

### 전통적인 메시지 큐와 다른 점

- RabbitMQ와 같은 전통적인 메시지 큐는 이벤트 스트리밍 플랫폼처럼 메시지 보관 문제를 중요하게 다루지 않음
- 전통적인 큐는 메시지가 소비자에 전달되기 충분한 기간 동안만 메모리에 보관
- 처리 용량을 넘어선 메시지 → 디스크에 보관 (이벤트 스트리밍 플랫폼이 감당하는 용량보다는 아주 낮은 수준)
- 전통적인 메시지 큐는 메시지 전달 순서도 보존하지 않음 → 생산된 순서와 소비되는 순서는 다를 수 있음

## 2단계: 개략적 설계안 제시 및 동의 구하기

> 생산자 → 메시지 생산 → 메시지 큐 ← 구독 ← 소비자
생산자 → 메시지 생산 → 메시지 큐 → 소비 → 소비자
> 
- 생산자는 메시지를 메시지 큐에 발행
- 소비자는 큐를 구독하고 구독한 메시지를 소비
- 메시지 큐는 생산자와 소비자 사이의 결합을 느슨하게 하는 서비스
    - 생산자와 소비자의 독립적인 운영 및 규모 확장을 가능하게함
- C/S 모델 관점
    - 프로듀서, 컨슈머: 클라이언트
    - 메시지 큐: 서버 역할
    - 클라이언트와 서버는 네트워크를 통해 통신

### 메시지 모델:

- `일대일` (point-to-point) 모델:
    - 오직 하나의 컨슈머만 소비 가능
    - Acknowledge → 메시지는 큐에서 삭제
    - 데이터 보관 지원 X
    - 컨슈머 그룹을 통해 지원 가능
- `발행-구독` (publish-subscribe) 모델:
    
    > 토픽(topic): 메시지를 주제별로 정리하는데 사용
    각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 갖음
    > 
    - 메시지를 보내고 받을 때, 토픽에 보내고 받음
    - 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에 전달

### 토픽, 파티션, 브로커

- 메시지는 토픽에 보관 → 토픽에 보관되는 데이터의 양이 커져서 감당하기 힘들면?
    - 파티션 → 샤딩 기법 활용
        - 토픽을 여러 파티션으로 분할
        - 메시지를 모든 파티션에 균등하게 나눠 보냄
        - 파티션은 메시지 큐 클러스터 내의 서버에 고르게 분산 배치
        - 파티션을 유지하는 서버는 보통 `브로커`(borker)라고 함
        - 파티션을 브로커에 분산하는 것 → 높은 규모 확장성을 달성하는 비결!
        - 토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨
        - 각 토픽 파티션은 FIFO 큐처럼 동작
        - **같은 파티션 안에서는 메시지 순서 유지**
        - 파티션 내에서의 메시지 위치를 `오프셋`(offset)이라고 함
        - 메시지에 user_id 같은 키를 붙일 수 있음 → 같은 키를 가진 모든 메시지는 같은 파티션으로 보내짐
        - 키가 없는 메시지는 무작위로 선택된 파티션으로 전송
        - 토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 가져옴
        - 토픽을 구독하는 소비자가 여럿인 경우, 각 구독자는 해당 토픽을 구성하는 파티션의 일부를 담당
        - 이러한 소비자들을 해당 토픽의 `소비자 그룹`(consumer group)이라고 부름