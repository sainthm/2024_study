### 4장 요약

# 4장. 분산 메시지 큐

> 시스템 설계 면접에 단골로 출제되는 문제인, 분산 메시지 큐 설계
> 
- 현대적 소프트웨어 아키텍처를 따르는 시스템은 잘 정의된 인터페이스를 경계로 나뉜 작고 독립적인 블록들로 구성
- 메시지 큐는 이 `블록 사이의 통신과 조율 담당`
- 유명 분산 메시지 큐:
    - 아파치 Kakka
    - 아파티 RocketMQ
    - 아파치 RabbitMQ
    - 아파치 Pulsar
    - 아파치 ActiveMQ
    - ZeroMQ

### 메시지 큐 장점:

- 결합도 완화(decoupling): 각각을 독립적으로 갱신 가능
- 규모 확장성 개선:
    - 아래의 컴포넌트를 시스템 규모에 대한 트래픽 부하에 맞게 독립적으로 늘릴 수 있음
        - 생산자(producer): 메시지 큐에 데이터 생산
        - 소비자(consumer): 큐에서 메시지를 소비
- 가용성 개선
- 성능 개선:
    - 비동기 통신이 쉽게 가능해짐
    - 서로를 기다릴 필요가 없어짐

### 메시지 큐 vs 이벤트 스트리밍 플랫폼

> 이번 장에서는 데이터 장기 보관, 메시지 반복 소비 등의 부가 기능을 갖춘 분산 메시지 큐 설계
> 
- 엄밀히 말하면 카프카와 펄사는 이벤트 스트리밍 플랫폼
- 지원하는 기능이 서로 수렴하며 구분이 희미해지고있음

## 1단계: 문제 이해 및 설계 범위 확정

> 프로듀서는 메시지를 큐에 보내고, 컨슈머는 큐에서 메시지를 꺼낸다.
> 
- 기본 기능 외에도 성능, 메시지 전달 방식, 데이터 보관 기관 등 고려할 사항 다양함
- 메시지의 형태와 평균 크기
- 텍스트 메시지 / 멀티미디어 지원
- 메시지의 반복적 소비 가능성
- 여러 컨슈머가 수신 가능해야 하는지
- 전달된 순서대로 소비되어야 하는지
- 데이터의 지속성 보장 여부
- 데이터의 보관 기간
- 프로듀서와 컨슈머의 수
- 메시지 전달 방식
    - 최대 한 번
    - 최소 한 번
    - 정확히 한 번
- 대역폭
- 엔드 투 엔드 지연시간

### 전통적인 메시지 큐와 다른 점

- RabbitMQ와 같은 전통적인 메시지 큐는 이벤트 스트리밍 플랫폼처럼 메시지 보관 문제를 중요하게 다루지 않음
- 전통적인 큐는 메시지가 소비자에 전달되기 충분한 기간 동안만 메모리에 보관
- 처리 용량을 넘어선 메시지 → 디스크에 보관 (이벤트 스트리밍 플랫폼이 감당하는 용량보다는 아주 낮은 수준)
- 전통적인 메시지 큐는 메시지 전달 순서도 보존하지 않음 → 생산된 순서와 소비되는 순서는 다를 수 있음

## 2단계: 개략적 설계안 제시 및 동의 구하기