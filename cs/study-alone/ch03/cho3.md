# Chapter 3. 명령어

- 고급 언어와 저급 언어
- 컴파일 언어와 인터프리터 언어
- 명령어를 구성하는 연산 코드와 오퍼랜드
- 명령어의 주소 지정 방식

## 소스 코드와 명령어

- 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환
- 컴퓨터가 이해하고 실행할 수 있는 언어는 오직 저급 언어!!
- 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어(명령어)로 변환되어야함!

### 고급 언어와 저급 언어

- **고급 언어** (Hig-level programming language)
  - 사람을 위한 언어
  - 대부분의 프로그래밍 언어
- **저급 언어** (Low-level programming language)
  - 컴퓨터가 직접 이해하고 실행할 수 있는 언어
  - 명령어로 구성
  - 두 가지 종류가 존재
    - **기계어**
      - Machine code
      - 0과 1의 명령어 비트로 이루어진 언어
      - 오로지 컴퓨터만을 위해 만들어진 언어
    - **어셈블리어**
      - Assembly language
      - 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어

### 컴파일 언어와 인터프리터 언어

- **컴파일 언어**
  - 컴파일러에 의해 소스 코드 전체가 저급 언어로 변횐되어 실행되는 고급 언어
  - **컴파일**: 코드 전체가 저급 언어로 변환되는 과정
  - 컴파일러: 컴파일을 수행하는 도구
    - 소스 코드 내에서 오류를 하나라도 발견하면 해당 소스 코드는 컴파일 실패
  - 목적 코드(Object code): 컴파일러를 통해 저급 언어로 변환된 코드

- **인터프리터 언어**
  - 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
  - **인터프리터**: 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해주는 도구

- 목적 파일 vs 실행 파일
  - 목적 코드가 실행 파일이 되기 위해서는 **링킹** 작업 필요

## 명령어의 구조

### 연산 코드와 오퍼랜드

- **명령어**는 "무엇을 대상으로, 어떤 작동을 수행하라" 라는 구조
- 명령어는 연산 코드와 오퍼랜드로 구성
  - **연산 코드**:
    - Operation code
    - 연산자
    - 명령어가 수행할 연산
    - 종류:
      - 데이터 전송
      - 산술/논리 연산
      - 제어 흐름 변경
      - 입출력 제어
  - **오퍼랜드**:
    - Operand
    - 피연산자
    - 주소 필드
    - 연산에 사용할 데이터
    - 연산에 사용할 데이터가 저장된 위치
      - 메모리 주소, 레지스터 이름
    - 종류:
      - 0-주소 명령어 (오퍼랜드가 없는 경우)
      - 1-주소 명령어
      - 2-주소 명령어
      - 3-주소 명령어

### 주소 지정 방식

- Addressing mode
- 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
- 유효 주소 (effective address): 연산의 대상이 되는 데이터가 저장된 위치
- 종류:
  - 즉시 주소 지정 방식:
    - Immediate addressing mode
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
    - 표현할 수 있는 데이터의 크기가 작아짐
    - 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 빠름
  - 직접 주소 지정 방식:
    - Direct addressing mode
    - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
    - 표현할 수 있는 유효 주소에 제한이 있을 수 있음
  - 간접 주소 지정 방식:
    - Indirect addressing mode
    - 유효 주소의 주소를 오퍼랜드 필드에 명시
    - 두 번의 메모리 접근이 필요하므로 위의 방식보다 느림
  - 레지스터 주소 지정 방식:
    - Register addressing mode
    - 직접 주소 지정 방식과 유사하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
    - 레지스터 접근이 메모리 접근보다는 빠름
    - 표현할 수 있는 레지스터 크기에 제한이 있을 수 있음
  - 레지스터 간접 주소 지정 방식:
    - Register indirect addressing mode
    - 연산에 사용할 데이터를 메모리에 저장
    - 저장된 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
    - 메모리 접근 횟수가 한 번

### 스택과 큐

- **스택**:
  - Stack
  - 한쪽 끝이 막혀있는 통과 같은 저장 공간
  - 저장한 자료를 빼낼 때, 마지막으로 저장한 데이터부터 빼냄
  - LIFO (Last In First Out, 후입선출)
- **큐**:
  - Queue
  - 양쪽이 뚫려 있는 관과 같은 저장 공간
  - 한쪽으로 데이터를 저장하고 다른 한쪽으로 먼저 저장한 순서대로 데이터를 빼냄
  - FIFO (Firtst In First Out, 선입선출)